# Bill Haven: Deployment & Security Checklist

Complete deployment procedures, security hardening, and production readiness guide.

---

## Pre-Deployment Security Checklist

### Database Security

- [ ] **Enable RLS on all tables** - Verify every table has Row Level Security enabled
  ```sql
  SELECT tablename FROM pg_tables WHERE schemaname='public'
  AND tablename NOT LIKE 'pg_%';

  -- For each table:
  ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;
  ```

- [ ] **Test RLS policies** - Verify policies work as expected
  ```sql
  -- Test as specific user
  SET ROLE authenticated;
  SELECT set_config('request.jwt.claims',
    '{"sub":"test-uuid","role":"authenticated"}', true);
  SELECT * FROM public.bills;
  ```

- [ ] **Enable SSL/TLS** - Enforce encrypted connections
  ```sql
  -- Check Supabase dashboard > Project Settings > Database
  -- Should show: "Require SSL: Yes"
  ```

- [ ] **Configure database backups** - Enable automated backups
  - Go to **Project Settings** > **Backups**
  - Enable **Point-in-Time Recovery (PITR)**
  - Set retention to 7+ days
  - Test restore process monthly

- [ ] **Set up audit logging** - Track all sensitive operations
  ```sql
  CREATE TABLE IF NOT EXISTS public.audit_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID,
    action TEXT NOT NULL,
    table_name TEXT,
    record_id BIGINT,
    changes JSONB,
    ip_address INET,
    created_at TIMESTAMPTZ DEFAULT NOW()
  );

  CREATE INDEX idx_audit_logs_user_id ON public.audit_logs(user_id);
  CREATE INDEX idx_audit_logs_created_at ON public.audit_logs(created_at DESC);
  ```

- [ ] **Restrict connection from specific IPs** - If using Supabase Pro
  - Configure network ACLs in project settings
  - Whitelist only production app servers

- [ ] **Use strong database passwords** - Generated by Supabase
  - Change default passwords
  - Store in secrets manager (AWS Secrets Manager, HashiCorp Vault)
  - Never commit to git

### Authentication Security

- [ ] **Enable email verification** - Require users to confirm email
  - **Authentication** > **Email Settings** > **Enable "Confirm email"**
  - Configure redirect URL to confirmation page

- [ ] **Enable Multi-Factor Authentication (MFA)** - At least for admins
  - **Authentication** > **MFA Settings**
  - Make required for admin users

- [ ] **Configure CORS properly** - Only allow trusted origins
  ```typescript
  // Supabase Dashboard > Project Settings > API > CORS Allowed Origins
  // Production: https://billhaven.app
  // Staging: https://staging.billhaven.app
  // Development: http://localhost:5173 (dev only)
  ```

- [ ] **Set secure session timeout** - Force re-authentication periodically
  ```typescript
  // src/contexts/AuthContext.tsx
  const SESSION_TIMEOUT_MS = 30 * 60 * 1000; // 30 minutes

  useEffect(() => {
    const timer = setTimeout(() => {
      supabase.auth.signOut();
      alert('Your session has expired. Please log in again.');
    }, SESSION_TIMEOUT_MS);

    return () => clearTimeout(timer);
  }, []);
  ```

- [ ] **Implement password complexity requirements**
  ```typescript
  const validatePasswordStrength = (password: string): boolean => {
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /[0-9]/.test(password);
    const hasSpecialChar = /[!@#$%^&*]/.test(password);
    const isLongEnough = password.length >= 12;

    return hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar && isLongEnough;
  };
  ```

- [ ] **Disable password reset if unused** - Prevent account takeover
  - Configure email templates to expire reset links after 1 hour

### API Security

- [ ] **Enable HTTPS everywhere** - Redirect HTTP to HTTPS
  ```typescript
  // Next.js or Express middleware
  if (process.env.NODE_ENV === 'production' && req.protocol !== 'https') {
    return res.redirect(301, `https://${req.get('host')}${req.originalUrl}`);
  }
  ```

- [ ] **Implement rate limiting** - Prevent brute force and DoS
  ```typescript
  // src/lib/rateLimiter.ts
  import rateLimit from 'express-rate-limit';

  export const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // 5 requests per windowMs
    message: 'Too many login attempts, please try again later'
  });

  export const apiLimiter = rateLimit({
    windowMs: 60 * 1000, // 1 minute
    max: 100, // 100 requests per minute
  });
  ```

- [ ] **Add CSP (Content Security Policy) headers**
  ```typescript
  // middleware or server config
  app.use((req, res, next) => {
    res.setHeader(
      'Content-Security-Policy',
      "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"
    );
    next();
  });
  ```

- [ ] **Implement CSRF protection**
  ```typescript
  // Use tokens for form submissions
  import csrf from 'csurf';
  const csrfProtection = csrf({ cookie: false });

  app.post('/api/bills', csrfProtection, (req, res) => {
    // Verify CSRF token before processing
  });
  ```

- [ ] **Validate all input** - Server-side validation always
  ```typescript
  const validateBillInput = (data: any) => {
    if (typeof data.title !== 'string' || data.title.length === 0) {
      throw new Error('Invalid title');
    }
    if (typeof data.amount !== 'number' || data.amount <= 0) {
      throw new Error('Invalid amount');
    }
    if (new Date(data.due_date) <= new Date()) {
      throw new Error('Invalid due date');
    }
    // ... more validation
    return true;
  };
  ```

- [ ] **Sanitize outputs** - Prevent XSS attacks
  ```typescript
  import DOMPurify from 'dompurify';

  const safeHTML = DOMPurify.sanitize(userInput);
  ```

### Cryptocurrency Security

- [ ] **Never store private keys** - Only store public addresses
  ```typescript
  // WRONG
  const storePrivateKey = (key) => db.insert('wallets', { private_key: key });

  // CORRECT
  const storeWalletAddress = (address) => db.insert('wallets', { address });
  ```

- [ ] **Implement nonce for wallet auth** - Prevent replay attacks
  ```typescript
  const generateWalletNonce = async (address: string) => {
    const nonce = `${Date.now()}_${Math.random().toString(36).substring(7)}`;
    await supabase
      .from('profiles')
      .update({ wallet_nonce: nonce, wallet_nonce_expires_at: new Date() })
      .eq('wallet_address', address);
    return nonce;
  };
  ```

- [ ] **Validate wallet addresses** - Check format and checksum
  ```typescript
  import { ethers } from 'ethers';

  const isValidAddress = (address: string) => {
    try {
      return ethers.isAddress(address);
    } catch {
      return false;
    }
  };
  ```

- [ ] **Rate limit transaction submissions** - Prevent spam
  ```typescript
  const MAX_TRANSACTIONS_PER_HOUR = 10;

  const checkTransactionRateLimit = async (userId: string) => {
    const { data: transactions } = await supabase
      .from('transactions')
      .select('id')
      .eq('payer_id', userId)
      .gt('created_at', new Date(Date.now() - 3600000).toISOString());

    return (transactions?.length || 0) < MAX_TRANSACTIONS_PER_HOUR;
  };
  ```

- [ ] **Verify blockchain state independently** - Don't trust client
  ```typescript
  const verifyTransaction = async (txHash: string, rpcUrl: string) => {
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    const receipt = await provider.getTransactionReceipt(txHash);

    // Verify amount matches
    // Verify recipient address matches
    // Verify sufficient confirmations

    return receipt !== null;
  };
  ```

- [ ] **Set transaction amount limits** - Per transaction and per user
  ```typescript
  const MAX_TRANSACTION_AMOUNT = 50000; // USD
  const MAX_DAILY_AMOUNT = 100000; // USD

  const validateTransactionAmount = async (userId: string, amount: number) => {
    if (amount > MAX_TRANSACTION_AMOUNT) {
      throw new Error('Transaction exceeds maximum amount');
    }

    const { data: dailyTransactions } = await supabase
      .from('transactions')
      .select('amount_paid')
      .eq('payer_id', userId)
      .gt('created_at', new Date(Date.now() - 86400000).toISOString());

    const dailyTotal = dailyTransactions?.reduce((sum, tx) => sum + tx.amount_paid, 0) || 0;
    if (dailyTotal + amount > MAX_DAILY_AMOUNT) {
      throw new Error('Daily transaction limit exceeded');
    }
  };
  ```

- [ ] **Implement fraud detection** - Monitor suspicious patterns
  ```typescript
  const detectFraud = async (userId: string, transactionData: any) => {
    // Check for unusual patterns
    const { data: recentTransactions } = await supabase
      .from('transactions')
      .select('amount_paid, created_at')
      .eq('payer_id', userId)
      .order('created_at', { ascending: false })
      .limit(10);

    // Flag if:
    // - 3+ failed attempts in 15 minutes
    // - Amount spike > 5x average
    // - Multiple recipients in short timeframe
    // - Geographic location change

    return fraudScore > FRAUD_THRESHOLD;
  };
  ```

### File Upload Security

- [ ] **Validate file types** - Check magic bytes, not just extension
  ```typescript
  const validateFileType = (file: File): boolean => {
    const validMimeTypes = ['application/pdf', 'image/jpeg', 'image/png'];
    return validMimeTypes.includes(file.type);
  };
  ```

- [ ] **Scan for malware** - Integrate with virus scanning service
  ```typescript
  import VirusTotal from 'virustotal.js';

  const scanFileForMalware = async (file: File) => {
    const vt = new VirusTotal(process.env.VIRUSTOTAL_API_KEY);
    const result = await vt.scan(file);
    return result.undetected;
  };
  ```

- [ ] **Enforce file size limits** - 10-100MB max
  ```typescript
  const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

  if (file.size > MAX_FILE_SIZE) {
    throw new Error('File size exceeds limit');
  }
  ```

- [ ] **Use signed URLs for downloads** - Expiring URLs only
  ```typescript
  const getSignedUrl = async (filePath: string) => {
    const { data, error } = await supabase.storage
      .from('bill_documents')
      .createSignedUrl(filePath, 60 * 60 * 24); // 24 hours

    return data.signedUrl;
  };
  ```

### Application Secrets Management

- [ ] **Use environment variables** - Never hardcode secrets
  ```bash
  # .env.production
  VITE_SUPABASE_URL=https://xxx.supabase.co
  VITE_SUPABASE_ANON_KEY=xxx
  ```

- [ ] **Rotate API keys regularly** - Every 90 days
  ```bash
  # In Supabase dashboard:
  # Settings > API > Key Management > Rotate Keys
  ```

- [ ] **Use secrets manager** - AWS Secrets Manager, HashiCorp Vault
  ```typescript
  import AWS from 'aws-sdk';

  const secretsManager = new AWS.SecretsManager();
  const secret = await secretsManager.getSecretValue({
    SecretId: 'bill-haven/supabase-key'
  }).promise();
  ```

- [ ] **Audit secret access** - Log who accessed what and when
  ```typescript
  const logSecretAccess = (secretName: string, userId: string) => {
    supabase.from('audit_logs').insert({
      action: 'SECRET_ACCESS',
      secret_name: secretName,
      user_id: userId,
      timestamp: new Date()
    });
  };
  ```

---

## Production Deployment Steps

### Phase 1: Pre-Deployment (1 week before)

- [ ] Complete all security checklist items above
- [ ] Conduct security code review
- [ ] Perform penetration testing (hire security firm)
- [ ] Load test the application (simulate 1000+ concurrent users)
- [ ] Test database backup and recovery process
- [ ] Set up monitoring and alerting

### Phase 2: Infrastructure Setup

#### Supabase Project Configuration

```bash
# 1. Create production Supabase project (separate from dev)
# Go to supabase.com > Create new project
# Select production tier for dedicated resources

# 2. Run database migrations
supabase db push --remote

# 3. Configure backups
# Dashboard > Project Settings > Backups > Enable PITR

# 4. Set up custom domain (optional)
# Supabase > Settings > General > Custom Domain

# 5. Enable network restrictions (Pro plan)
# Settings > Network > Add IP whitelist
```

#### Application Server Setup

```bash
# Deploy to Vercel, Netlify, or your own server
# Vercel example:
vercel --prod

# Or use Docker:
docker build -t bill-haven .
docker push your-registry/bill-haven:latest

# Deploy to Kubernetes
kubectl apply -f deployment.yaml
```

#### Environment Configuration

```bash
# Create .env.production with production credentials
VITE_SUPABASE_URL=https://prod-xxx.supabase.co
VITE_SUPABASE_ANON_KEY=prod-key-xxx
VITE_APP_URL=https://billhaven.app
NODE_ENV=production
```

### Phase 3: Pre-Launch Testing

- [ ] **Smoke testing** - Basic functionality works
  ```bash
  npm run test:smoke
  ```

- [ ] **Security testing** - OWASP Top 10
  ```bash
  npm run test:security
  ```

- [ ] **Load testing** - Handle peak traffic
  ```bash
  npm run test:load
  ```

- [ ] **End-to-end testing** - Complete user flows
  ```bash
  npm run test:e2e
  ```

### Phase 4: Monitoring Setup

#### Application Monitoring

```typescript
// src/lib/monitoring.ts
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  environment: import.meta.env.MODE,
  tracesSampleRate: 0.1,
});

export const captureException = (error: Error, context?: Record<string, any>) => {
  Sentry.captureException(error, { extra: context });
};
```

#### Database Monitoring

```sql
-- Create monitoring views
CREATE VIEW public.database_stats AS
SELECT
  (SELECT count(*) FROM public.bills) as total_bills,
  (SELECT count(*) FROM public.transactions) as total_transactions,
  (SELECT count(DISTINCT payer_id) FROM public.transactions) as unique_payers,
  (SELECT sum(amount_paid) FROM public.transactions) as total_volume;
```

#### Infrastructure Monitoring

```typescript
// Monitor with Datadog, New Relic, or similar
// Metrics to track:
// - API response time (p50, p95, p99)
// - Database query time
// - Error rates
// - Transaction confirmation time
// - Wallet connection success rate
```

### Phase 5: Go Live

```bash
# 1. Final backup
supabase db backup create

# 2. Deploy frontend
vercel --prod

# 3. Monitor logs for errors
tail -f logs/production.log

# 4. Send notification to users
# Email: New Bill Haven is live!

# 5. Monitor first 24 hours closely
# Check:
# - Error rates
# - Response times
# - User signups
# - Payment success rate
```

---

## Post-Deployment Monitoring

### Daily Checks

- [ ] Check error logs for critical errors
- [ ] Monitor transaction success rate (should be >99%)
- [ ] Verify database backups completed
- [ ] Review security logs for suspicious activity
- [ ] Check system resource usage (CPU, memory, storage)

### Weekly Checks

- [ ] Review analytics dashboard
- [ ] Check for failed user signups
- [ ] Verify all email notifications delivered
- [ ] Test disaster recovery procedure
- [ ] Review and update security rules as needed

### Monthly Checks

- [ ] Conduct security audit
- [ ] Review and optimize slow queries
- [ ] Update dependencies (npm, Python, etc.)
- [ ] Rotate API keys and secrets
- [ ] Test failover procedures
- [ ] Review compliance requirements (GDPR, etc.)

---

## Security Incident Response

### If Data Breach Suspected

1. **Immediate Actions (within 1 hour)**
   ```bash
   # 1. Disable user accounts if compromised
   UPDATE auth.users SET confirmed_at = NULL WHERE id = 'breached_user_id';

   # 2. Revoke API keys
   # Supabase > Settings > API > Keys > Revoke

   # 3. Notify affected users
   # Send email: "Your account may have been compromised. Please change your password."
   ```

2. **Investigation (within 24 hours)**
   ```sql
   -- Check audit logs for suspicious activity
   SELECT * FROM public.audit_logs
   WHERE created_at > NOW() - INTERVAL '24 hours'
   ORDER BY created_at DESC;

   -- Check for unauthorized transactions
   SELECT * FROM public.transactions
   WHERE status = 'failed' AND created_at > NOW() - INTERVAL '24 hours';
   ```

3. **Communication**
   - Notify customers immediately
   - Post status update on website
   - Contact regulatory bodies if required (GDPR, etc.)

### If Service Outage

1. **Status Page**
   - Use Statuspage.io or similar
   - Update status every 30 minutes
   - Post incident timeline when resolved

2. **Recovery Process**
   ```bash
   # Check service status
   supabase status

   # Restore from backup if needed
   supabase db restore --backup-id backup_xxx

   # Clear cache
   redis-cli FLUSHALL

   # Restart services
   docker-compose restart
   ```

---

## Disaster Recovery Plan

### RTO (Recovery Time Objective): < 1 hour
### RPO (Recovery Point Objective): < 15 minutes

```bash
# Monthly disaster recovery test

# 1. Simulate data loss
supabase db list-backups

# 2. Restore from backup to staging
supabase db restore --backup-id backup_xxx --project staging_project_id

# 3. Verify data integrity
SELECT COUNT(*) FROM public.bills;
SELECT COUNT(*) FROM public.transactions;

# 4. Test application functionality
npm run test:e2e

# 5. Document results and update procedures if needed
echo "Disaster Recovery Test - $(date)" >> DISASTER_RECOVERY_LOG.txt
```

---

## Compliance & Legal

### GDPR Compliance

```typescript
// Right to be forgotten
export const deleteUserData = async (userId: string) => {
  // 1. Delete user auth
  await supabase.auth.admin.deleteUser(userId);

  // 2. Anonymize profile
  await supabase
    .from('profiles')
    .update({
      full_name: 'DELETED_USER',
      email: null,
      wallet_address: null
    })
    .eq('id', userId);

  // 3. Delete files
  const { data: files } = await supabase.storage
    .from('bill_documents')
    .list(`${userId}`);

  for (const file of files || []) {
    await supabase.storage
      .from('bill_documents')
      .remove([`${userId}/${file.name}`]);
  }

  // 4. Log deletion
  await supabase.from('audit_logs').insert({
    action: 'USER_DELETED',
    user_id: userId,
    created_at: new Date()
  });
};
```

### Terms of Service

Must include:
- Data collection and usage policies
- Liability limitations
- Cryptocurrency risk disclaimer
- User responsibilities
- Dispute resolution process

### Privacy Policy

Must include:
- What data is collected
- How data is used
- Data retention periods
- User rights
- Data deletion procedures
- Third-party integrations (Sentry, analytics, etc.)

---

## Performance Optimization

### Database Optimization

```sql
-- Analyze query performance
EXPLAIN ANALYZE
SELECT * FROM public.bills
WHERE user_id = 'xxx'
ORDER BY created_at DESC;

-- Create indexes for common queries
CREATE INDEX idx_bills_user_id_status ON public.bills(user_id, status);
CREATE INDEX idx_transactions_payer_created ON public.transactions(payer_id, created_at);

-- Check for missing indexes
SELECT * FROM pg_stat_user_tables
ORDER BY seq_scan DESC
LIMIT 10;
```

### API Response Optimization

```typescript
// Enable caching
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 300 }); // 5 minutes

app.get('/api/bills/:id', (req, res) => {
  const cacheKey = `bill_${req.params.id}`;
  const cached = cache.get(cacheKey);

  if (cached) {
    return res.json(cached);
  }

  const bill = await fetchBill(req.params.id);
  cache.set(cacheKey, bill);
  res.json(bill);
});
```

### Frontend Optimization

```typescript
// Code splitting
const Dashboard = lazy(() => import('./pages/Dashboard'));
const AdminPanel = lazy(() => import('./pages/AdminPanel'));

// Image optimization
<img
  src="image.jpg"
  srcSet="image-small.jpg 480w, image-medium.jpg 1024w"
  sizes="(max-width: 640px) 480px, 1024px"
/>

// Lazy loading
<img loading="lazy" src="document.pdf" />
```

---

## Conclusion

This deployment and security guide provides comprehensive coverage of all aspects needed for a production-ready, secure Bill Haven platform.

**Key Takeaways:**
1. Security is not optional - implement all checklist items
2. Test thoroughly before production
3. Monitor continuously after launch
4. Have incident response procedures ready
5. Keep systems updated and patched
6. Maintain comprehensive audit logs
7. Regular security audits recommended

**Support:**
- Supabase Docs: https://supabase.com/docs
- Security Best Practices: https://owasp.org/
- Ethereum Security: https://ethereum.org/developers/docs/smart-contracts/security/
