# Supabase + Web3 Integration Guide for BillHaven

*Generated by Gemini Research Agent - 2025-11-28*

## Overview
This guide covers best practices for integrating Supabase with Web3 cryptocurrency wallets for the BillHaven bill payment platform.

---

## 1. Best Practices for Storing Cryptocurrency Data

### Wallet Address Storage

A user's wallet address is public information. You can store it directly in your `profiles` table or a dedicated `wallets` table.

**Should they be encrypted?** Generally, no. Wallet addresses are public keys and do not need to be encrypted at rest. Encrypting them can add unnecessary complexity to your application. However, be mindful of user privacy. Tying a wallet address to a user's real-world identity (e.g., name, email) should be handled with care.

**Example Supabase Table (`profiles`):**

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  wallet_address TEXT UNIQUE,
  -- other profile data
);
```

### Private Key Handling

**DO NOT STORE PRIVATE KEYS.**

**Why?** Private keys are the "keys to the kingdom." If your database is ever compromised, and you have stored private keys, attackers will have full control over your users' funds. All transactions should be signed on the client-side (in the user's wallet), and your backend should only ever deal with signed messages and transactions.

> **Security Warning:** Never, under any circumstances, ask for or store a user's private key or seed phrase.

### Transaction Hash Storage and Verification

A transaction hash (TxID) is a unique identifier for a transaction on the blockchain. Storing transaction hashes is crucial for tracking the status of payments.

- **Storage:** Store the transaction hash in a `transactions` table, linked to the user and the bill they are paying.
- **Verification:** Once you have the transaction hash, you can use a blockchain explorer API (like Etherscan for Ethereum) or a node provider (like Infura or Alchemy) to verify the transaction's status (pending, successful, or failed).

**Example Supabase Table (`transactions`):**

```sql
CREATE TABLE transactions (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES profiles(id),
  bill_id BIGINT REFERENCES bills(id),
  tx_hash TEXT UNIQUE,
  status TEXT DEFAULT 'pending', -- e.g., pending, confirmed, failed
  token_type TEXT, -- e.g., ETH, BTC, MATIC, TRX
  amount NUMERIC,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Token Type Handling

Your platform will likely support multiple cryptocurrencies. You need a way to handle different token types.

- **Storage:** You can store the token type as a string (e.g., "ETH", "BTC") or use an `enum` for better data integrity. For ERC-20 tokens, you will also need to store the contract address.

**Example using an `enum`:**

```sql
CREATE TYPE token_symbol AS ENUM ('BTC', 'ETH', 'MATIC', 'TRX');

CREATE TABLE transactions (
  -- ... other columns
  token token_symbol,
  -- ...
);
```

---

## 2. Authentication Flow

The authentication flow for a Web3 application is different from traditional email/password systems. Here's how to implement a secure "Sign-In with Ethereum" (SIWE) style authentication with Supabase.

### Wallet Connection Methods

On your frontend, you'll need a way for users to connect their wallets. Libraries like `ethers.js` or `web3.js` are essential for this. You can use tools like:

- **MetaMask:** The most popular browser extension wallet.
- **WalletConnect:** A protocol that allows users to connect mobile wallets to your dApp.

**Example (Frontend - React):**

```jsx
import { ethers } from 'ethers';

async function connectWallet() {
  if (window.ethereum) {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = provider.getSigner();
      const address = await signer.getAddress();
      return { signer, address };
    } catch (error) {
      console.error("Error connecting to wallet:", error);
    }
  } else {
    alert("Please install MetaMask!");
  }
}
```

### Message Signing for Authentication (EIP-191)

To prove ownership of a wallet address, you ask the user to sign a message. This is a gas-free operation.

- **EIP-191:** This standard defines a format for signed messages, making it clear to the user that they are signing a message and not a transaction.

**Authentication Flow:**

1. **Frontend:** The user connects their wallet.
2. **Backend:** Your backend generates a unique, single-use message (a "nonce") for the user to sign.
3. **Frontend:** The user signs the message with their private key.
4. **Backend:** Your backend receives the signed message and the user's wallet address. It then uses cryptographic functions to recover the address that signed the message. If it matches the user's address, authentication is successful.

### Linking Wallet Addresses to Supabase Auth

Once you've verified the user's signature, you can create a Supabase user account for them and issue a JWT.

**Example (Backend - Supabase Edge Function):**

```typescript
// /supabase/functions/login/index.ts
import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';
import { ethers } from 'https://cdn.ethers.io/lib/ethers-5.6.esm.min.js';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

serve(async (req) => {
  const { address, signature, message } = await req.json();

  // 1. Verify the signature
  const recoveredAddress = ethers.utils.verifyMessage(message, signature);
  if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
    return new Response(JSON.stringify({ error: 'Invalid signature' }), { status: 401 });
  }

  // 2. Check the nonce (to prevent replay attacks)
  // (You would store and check nonces in your database)

  // 3. Create or get the user in Supabase
  const supabaseAdmin = createClient(
    Deno.env.get('SUPABASE_URL'),
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
  );

  let { data: user, error } = await supabaseAdmin.auth.admin.getUserById(address);
  if (!user) {
    // Create a new user
    const { data: newUser, error: createError } = await supabaseAdmin.auth.admin.createUser({
      email: `${address}@yourapp.com`,
      user_metadata: { wallet_address: address },
    });
    if (createError) throw createError;
    user = newUser.user;
  }

  return new Response(JSON.stringify({ user }), {
    headers: { 'Content-Type': 'application/json' },
  });
});
```

### Rate Limiting for Transaction Verification

To prevent abuse, you should rate-limit your authentication and transaction verification endpoints. You can implement this in your Supabase Edge Functions or using a middleware service.

---

## 3. Transaction Tracking

### Recording Pending Transactions

When a user initiates a payment on the frontend, they will get a transaction hash almost immediately. You should send this hash to your backend and create a `pending` transaction in your database.

**Flow:**

1. **Frontend:** User submits a transaction via their wallet.
2. **Frontend:** The wallet returns a `tx_hash`.
3. **Frontend:** The `tx_hash` is sent to your backend.
4. **Backend:** A new row is created in the `transactions` table with the status `pending`.

### Webhook/Polling Strategies for Confirmation

You need a way to know when a `pending` transaction is confirmed on the blockchain.

- **Polling:** You can write a script that periodically queries the blockchain for the status of all pending transactions. This is simple to implement but can be inefficient.
- **Webhooks (Recommended):** Services like Alchemy or Infura offer webhook services. You can subscribe to notifications for certain addresses, and they will send a POST request to your backend when a transaction is confirmed.

**Example (Backend - Supabase Edge Function for Webhook):**

```typescript
// /supabase/functions/transaction-webhook/index.ts
import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

serve(async (req) => {
  const payload = await req.json();
  const txHash = payload.event.transaction.hash;
  const status = payload.event.transaction.status;

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL'),
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
  );

  const newStatus = status === '0x1' ? 'confirmed' : 'failed';

  const { data, error } = await supabase
    .from('transactions')
    .update({ status: newStatus })
    .eq('tx_hash', txHash);

  if (error) {
    console.error('Error updating transaction:', error);
  }

  return new Response('OK');
});
```

### Storing Transaction Metadata

When a transaction is confirmed, you should store important metadata, such as:

- `gas_fee`: The cost of the transaction.
- `block_number`: The block in which the transaction was included.
- `slippage`: If you are dealing with token swaps.

This data is useful for debugging and for providing users with a detailed transaction history.

### Handling Failed/Reversed Transactions

Transactions can fail for various reasons (e.g., running out of gas). Your webhook or polling mechanism should be able to detect failed transactions and update the status in your database accordingly. You should also have a mechanism to notify the user that their payment failed.

---

## 4. Security Considerations

### Preventing Replay Attacks

A replay attack is when an attacker intercepts a signed message and reuses it to authenticate as the user. To prevent this, include a `nonce` (a single-use number) in the message that the user signs.

**Implementation:**

1. When a user wants to log in, your backend generates a random, unique `nonce`.
2. Store the `nonce` in the user's profile in your database.
3. The user signs a message that includes this `nonce`.
4. When your backend verifies the signature, it also checks that the `nonce` in the message matches the one in the database.
5. After a successful login, the `nonce` is deleted or changed so it cannot be used again.

### Validating Blockchain State

**Always trust the blockchain, not the client.** A malicious user could send you a fake transaction hash. Your backend should always independently verify the details of any transaction (amount, recipient, etc.) by querying the blockchain directly.

### Rate Limiting and Fraud Detection

Implement strict rate limiting on all sensitive endpoints. You can also implement fraud detection rules, such as:

- Flagging accounts with a high number of failed transactions.
- Monitoring for transactions from known malicious addresses.

### Audit Logs

Keep a detailed log of all cryptocurrency-related operations. This includes:

- Login attempts (successful and failed).
- Transaction submissions.
- Transaction status changes.

These logs are invaluable for security audits and for debugging issues.

---

## 5. Code Patterns

### TypeScript Interfaces for Crypto Data

Use TypeScript to define the shapes of your data structures.

```typescript
interface UserProfile {
  id: string;
  walletAddress: string;
  nonce?: string;
}

interface Transaction {
  id: number;
  userId: string;
  billId: number;
  txHash: string;
  status: 'pending' | 'confirmed' | 'failed';
  token: 'ETH' | 'BTC' | 'MATIC' | 'TRX';
  amount: number;
  createdAt: string;
  gasFee?: number;
  blockNumber?: number;
}
```

### Error Handling for Blockchain Interactions

All interactions with the blockchain can fail. Wrap your code in `try...catch` blocks and handle errors gracefully.

```typescript
async function verifyTransaction(txHash: string) {
  try {
    const provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL);
    const tx = await provider.getTransaction(txHash);
    if (tx && tx.confirmations > 0) {
      // Transaction is confirmed
    }
  } catch (error) {
    console.error(`Error verifying transaction ${txHash}:`, error);
    // Handle the error
  }
}
```

### Testing Strategies

Thoroughly test your application.

- **Unit Tests:** Test individual functions, such as signature verification and transaction status updates.
- **Integration Tests:** Test the interactions between your backend, Supabase, and a mock blockchain. Tools like Hardhat or Foundry allow you to run a local blockchain for testing.
- **End-to-End Tests:** Use a framework like Cypress or Playwright to test the entire user flow, from connecting a wallet to paying a bill.

---

## Conclusion

By following this guide, you can build a secure and reliable bill payment platform that leverages the power of Web3 and Supabase. Always stay up-to-date with the latest security best practices in the rapidly evolving world of cryptocurrency.
